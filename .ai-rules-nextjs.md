# Next.js Development Rules

## üö´ TypeScript: Never Use `any`

### ‚ùå AVOID
```typescript
const handleData = (data: any) => { /* ... */ }
const users: any[] = []
const config: any = {}
```

### ‚úÖ USE INSTEAD
```typescript
// Use proper types
const handleData = (data: User) => { /* ... */ }
const users: User[] = []

// Use unknown for truly unknown types, then narrow
const parseData = (data: unknown) => {
  if (isUser(data)) {
    return data // now typed as User
  }
}

// Use generics for flexible typing
function processItems<T>(items: T[]): T[] { /* ... */ }

// Use Record for object types
const config: Record<string, string | number> = {}

// Use type inference
const count = 5 // inferred as number
const name = "test" // inferred as string
```

---

## üö´ Avoid `useEffect` - There's Always a Better Way

### Common `useEffect` Anti-Patterns and Solutions

#### 1Ô∏è‚É£ Fetching Data on Mount

**‚ùå AVOID**
```typescript
function UserProfile({ userId }: { userId: string }) {
  const [user, setUser] = useState<User | null>(null)
  
  useEffect(() => {
    fetchUser(userId).then(setUser)
  }, [userId])
  
  return <div>{user?.name}</div>
}
```

**‚úÖ USE INSTEAD**
```typescript
// Option A: Server Components (Next.js 13+ App Router)
async function UserProfile({ userId }: { userId: string }) {
  const user = await fetchUser(userId) // Direct server-side fetch
  return <div>{user.name}</div>
}

// Option B: React Server Components with streaming
import { Suspense } from 'react'

function UserProfilePage({ userId }: { userId: string }) {
  return (
    <Suspense fallback={<Skeleton />}>
      <UserProfile userId={userId} />
    </Suspense>
  )
}

// Option C: SWR or React Query for client components
import useSWR from 'swr'

function UserProfile({ userId }: { userId: string }) {
  const { data: user, error, isLoading } = useSWR(`/api/users/${userId}`, fetcher)
  
  if (isLoading) return <Skeleton />
  if (error) return <Error />
  return <div>{user.name}</div>
}
```

#### 2Ô∏è‚É£ Syncing State with Props

**‚ùå AVOID**
```typescript
function SearchInput({ initialValue }: { initialValue: string }) {
  const [value, setValue] = useState(initialValue)
  
  useEffect(() => {
    setValue(initialValue) // Syncing state
  }, [initialValue])
  
  return <input value={value} onChange={e => setValue(e.target.value)} />
}
```

**‚úÖ USE INSTEAD**
```typescript
// Option A: Controlled component - lift state up
function SearchInput({ 
  value, 
  onChange 
}: { 
  value: string
  onChange: (value: string) => void 
}) {
  return <input value={value} onChange={e => onChange(e.target.value)} />
}

// Option B: Use key to reset component
function Parent() {
  const [searchTerm, setSearchTerm] = useState('')
  return <SearchInput key={searchTerm} defaultValue={searchTerm} />
}

// Option C: Derived state
function SearchInput({ initialValue }: { initialValue: string }) {
  const [localValue, setLocalValue] = useState(initialValue)
  const displayValue = localValue ?? initialValue // Derive, don't sync
  
  return <input value={displayValue} onChange={e => setLocalValue(e.target.value)} />
}
```

#### 3Ô∏è‚É£ Subscribing to External Stores

**‚ùå AVOID**
```typescript
function useOnlineStatus() {
  const [isOnline, setIsOnline] = useState(true)
  
  useEffect(() => {
    const handleOnline = () => setIsOnline(true)
    const handleOffline = () => setIsOnline(false)
    
    window.addEventListener('online', handleOnline)
    window.addEventListener('offline', handleOffline)
    
    return () => {
      window.removeEventListener('online', handleOnline)
      window.removeEventListener('offline', handleOffline)
    }
  }, [])
  
  return isOnline
}
```

**‚úÖ USE INSTEAD**
```typescript
import { useSyncExternalStore } from 'react'

function useOnlineStatus() {
  return useSyncExternalStore(
    (callback) => {
      window.addEventListener('online', callback)
      window.addEventListener('offline', callback)
      return () => {
        window.removeEventListener('online', callback)
        window.removeEventListener('offline', callback)
      }
    },
    () => navigator.onLine,
    () => true // SSR snapshot
  )
}
```

#### 4Ô∏è‚É£ Computing Derived State

**‚ùå AVOID**
```typescript
function ProductList({ products }: { products: Product[] }) {
  const [filteredProducts, setFilteredProducts] = useState<Product[]>([])
  const [searchTerm, setSearchTerm] = useState('')
  
  useEffect(() => {
    setFilteredProducts(
      products.filter(p => p.name.includes(searchTerm))
    )
  }, [products, searchTerm])
  
  return <div>{/* ... */}</div>
}
```

**‚úÖ USE INSTEAD**
```typescript
import { useMemo } from 'react'

function ProductList({ products }: { products: Product[] }) {
  const [searchTerm, setSearchTerm] = useState('')
  
  // Compute during render, memoize if expensive
  const filteredProducts = useMemo(
    () => products.filter(p => p.name.includes(searchTerm)),
    [products, searchTerm]
  )
  
  return <div>{/* ... */}</div>
}
```

#### 5Ô∏è‚É£ Handling Side Effects on User Actions

**‚ùå AVOID**
```typescript
function Form() {
  const [submitted, setSubmitted] = useState(false)
  
  useEffect(() => {
    if (submitted) {
      toast.success('Saved!')
      setSubmitted(false)
    }
  }, [submitted])
  
  const handleSubmit = () => setSubmitted(true)
  
  return <button onClick={handleSubmit}>Submit</button>
}
```

**‚úÖ USE INSTEAD**
```typescript
// Put the side effect directly in the event handler
function Form() {
  const handleSubmit = async () => {
    await saveData()
    toast.success('Saved!') // Side effect in handler, not effect
  }
  
  return <button onClick={handleSubmit}>Submit</button>
}
```

#### 6Ô∏è‚É£ Route/Search Params Manipulation

**‚ùå AVOID**
```typescript
'use client'
function FilterPage() {
  const [filter, setFilter] = useState('')
  const router = useRouter()
  
  useEffect(() => {
    router.push(`?filter=${filter}`)
  }, [filter, router])
  
  return <input value={filter} onChange={e => setFilter(e.target.value)} />
}
```

**‚úÖ USE INSTEAD**
```typescript
// Option A: Server Component with searchParams
function FilterPage({
  searchParams
}: {
  searchParams: { filter?: string }
}) {
  const filter = searchParams.filter ?? ''
  
  return (
    <form action={`/filter`} method="get">
      <input name="filter" defaultValue={filter} />
    </form>
  )
}

// Option B: Client Component with useTransition
'use client'
import { useRouter, useSearchParams } from 'next/navigation'
import { useTransition } from 'react'

function FilterPage() {
  const router = useRouter()
  const searchParams = useSearchParams()
  const [isPending, startTransition] = useTransition()
  
  const handleFilterChange = (value: string) => {
    startTransition(() => {
      const params = new URLSearchParams(searchParams)
      params.set('filter', value)
      router.push(`?${params.toString()}`)
    })
  }
  
  return <input onChange={e => handleFilterChange(e.target.value)} />
}
```

#### 7Ô∏è‚É£ Initialization Logic

**‚ùå AVOID**
```typescript
function App() {
  const [data, setData] = useState<Data | null>(null)
  
  useEffect(() => {
    const storedData = localStorage.getItem('data')
    if (storedData) {
      setData(JSON.parse(storedData))
    }
  }, [])
  
  return <div>{/* ... */}</div>
}
```

**‚úÖ USE INSTEAD**
```typescript
// Option A: Lazy initialization
function App() {
  const [data, setData] = useState<Data | null>(() => {
    if (typeof window === 'undefined') return null
    const storedData = localStorage.getItem('data')
    return storedData ? JSON.parse(storedData) : null
  })
  
  return <div>{/* ... */}</div>
}

// Option B: useSyncExternalStore for browser APIs
import { useSyncExternalStore } from 'react'

function useLocalStorage<T>(key: string, initialValue: T) {
  return useSyncExternalStore(
    (callback) => {
      window.addEventListener('storage', callback)
      return () => window.removeEventListener('storage', callback)
    },
    () => {
      const item = localStorage.getItem(key)
      return item ? JSON.parse(item) : initialValue
    },
    () => initialValue // SSR
  )
}
```

---

## üéØ Next.js Best Practices

### Server Components First

**‚úÖ Default to Server Components**
```typescript
// app/users/page.tsx - No 'use client'
async function UsersPage() {
  const users = await db.users.findMany() // Direct DB access!
  return <UserList users={users} />
}
```

**Only use 'use client' when necessary:**
- Interactive event handlers (onClick, onChange)
- Browser-only APIs (localStorage, window)
- React hooks (useState, useReducer, useContext)
- Third-party libraries that require client-side

### Data Fetching Patterns

**‚úÖ Parallel Data Fetching**
```typescript
async function Page() {
  // Fetches run in parallel
  const [users, posts] = await Promise.all([
    fetchUsers(),
    fetchPosts()
  ])
  
  return <div>{/* ... */}</div>
}
```

**‚úÖ Sequential with Suspense Boundaries**
```typescript
async function Page() {
  const users = await fetchUsers() // Critical data
  
  return (
    <div>
      <UserList users={users} />
      <Suspense fallback={<Skeleton />}>
        <Posts /> {/* Non-critical, can stream */}
      </Suspense>
    </div>
  )
}
```

**‚úÖ Revalidation Over Client-Side Fetching**
```typescript
// app/posts/page.tsx
export const revalidate = 60 // Revalidate every 60 seconds

async function PostsPage() {
  const posts = await fetchPosts()
  return <PostList posts={posts} />
}
```

### Form Handling

**‚úÖ Use Server Actions**
```typescript
// app/actions.ts
'use server'
export async function createUser(formData: FormData) {
  const name = formData.get('name') as string
  await db.users.create({ data: { name } })
  revalidatePath('/users')
  redirect('/users')
}

// app/users/new/page.tsx
import { createUser } from '@/app/actions'

function NewUserPage() {
  return (
    <form action={createUser}>
      <input name="name" required />
      <button type="submit">Create</button>
    </form>
  )
}
```

**‚úÖ Progressive Enhancement with useFormStatus**
```typescript
'use client'
import { useFormStatus } from 'react-dom'

function SubmitButton() {
  const { pending } = useFormStatus()
  
  return (
    <button type="submit" disabled={pending}>
      {pending ? 'Creating...' : 'Create User'}
    </button>
  )
}
```

### Avoid Client-Side State When Possible

**‚ùå AVOID**
```typescript
'use client'
function TodoList() {
  const [todos, setTodos] = useState([])
  
  useEffect(() => {
    fetch('/api/todos').then(r => r.json()).then(setTodos)
  }, [])
  
  return <div>{/* ... */}</div>
}
```

**‚úÖ USE SERVER COMPONENT**
```typescript
async function TodoList() {
  const todos = await db.todos.findMany()
  return <div>{/* ... */}</div>
}
```

### Image Optimization

**‚úÖ Always use next/image**
```typescript
import Image from 'next/image'

function Avatar({ src, alt }: { src: string; alt: string }) {
  return (
    <Image
      src={src}
      alt={alt}
      width={100}
      height={100}
      priority={false} // true for above-the-fold images
    />
  )
}
```

### Metadata and SEO

**‚úÖ Use generateMetadata for dynamic metadata**
```typescript
import type { Metadata } from 'next'

export async function generateMetadata({
  params
}: {
  params: { id: string }
}): Promise<Metadata> {
  const post = await fetchPost(params.id)
  
  return {
    title: post.title,
    description: post.excerpt,
    openGraph: {
      title: post.title,
      description: post.excerpt,
      images: [post.image]
    }
  }
}
```

---

## ÔøΩ HTTP Clients & Data Fetching

### ‚úÖ Prefer Native `fetch` Over Axios

**Why native `fetch`?**
- Built into Next.js with automatic request deduplication
- Works seamlessly with Server Components
- Supports Next.js caching and revalidation
- No extra dependencies

**‚ùå AVOID Axios in Server Components**
```typescript
// BAD - Unnecessary dependency
import axios from 'axios'

async function Users() {
  const { data } = await axios.get('/api/users')
  return <UserList users={data} />
}
```

**‚úÖ USE Native Fetch**
```typescript
// GOOD - Native fetch with Next.js caching
async function Users() {
  const res = await fetch('https://api.example.com/users', {
    next: { revalidate: 3600 } // Cache for 1 hour
  })
  const users = await res.json()
  return <UserList users={users} />
}

// With error handling
async function Users() {
  try {
    const res = await fetch('https://api.example.com/users')
    if (!res.ok) throw new Error('Failed to fetch users')
    const users = await res.json()
    return <UserList users={users} />
  } catch (error) {
    return <ErrorMessage error={error} />
  }
}
```

**When Axios is Acceptable:**
- Client-side fetching in 'use client' components (but prefer TanStack Query)
- Need specific features like interceptors
- Working with legacy code that already uses it

**‚úÖ If Using Axios, Create a Configured Instance**
```typescript
// lib/axios.ts
import axios from 'axios'

export const apiClient = axios.create({
  baseURL: process.env.NEXT_PUBLIC_API_URL,
  timeout: 10000,
  headers: {
    'Content-Type': 'application/json'
  }
})

// Add interceptors for auth, error handling, etc.
apiClient.interceptors.request.use((config) => {
  const token = getAuthToken()
  if (token) {
    config.headers.Authorization = `Bearer ${token}`
  }
  return config
})
```

---

## üì¶ State Management

### Server State vs Client State

**Server State** = Data from APIs, databases
**Client State** = UI state, form state, temporary data

### ‚úÖ TanStack Query (React Query) for Server State

**Use TanStack Query when you need:**
- Client-side data fetching
- Caching, refetching, and synchronization
- Optimistic updates
- Infinite scrolling or pagination
- Real-time data

**‚ùå AVOID useEffect for Data Fetching**
```typescript
'use client'
function Users() {
  const [users, setUsers] = useState<User[]>([])
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<Error | null>(null)
  
  useEffect(() => {
    fetch('/api/users')
      .then(r => r.json())
      .then(setUsers)
      .catch(setError)
      .finally(() => setLoading(false))
  }, [])
  
  // Manual cache invalidation, refetching logic...
}
```

**‚úÖ USE TanStack Query**
```typescript
'use client'
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query'

function Users() {
  const { data: users, isLoading, error } = useQuery({
    queryKey: ['users'],
    queryFn: async () => {
      const res = await fetch('/api/users')
      if (!res.ok) throw new Error('Failed to fetch')
      return res.json()
    },
    staleTime: 5 * 60 * 1000, // Consider fresh for 5 minutes
  })
  
  if (isLoading) return <Skeleton />
  if (error) return <Error error={error} />
  return <UserList users={users} />
}

// Mutations with automatic cache invalidation
function CreateUserButton() {
  const queryClient = useQueryClient()
  
  const mutation = useMutation({
    mutationFn: (newUser: NewUser) => 
      fetch('/api/users', {
        method: 'POST',
        body: JSON.stringify(newUser)
      }),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['users'] })
    }
  })
  
  return <button onClick={() => mutation.mutate({ name: 'John' })}>Create</button>
}
```

**Setup TanStack Query Provider**
```typescript
// app/providers.tsx
'use client'
import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
import { ReactQueryDevtools } from '@tanstack/react-query-devtools'
import { useState } from 'react'

export function Providers({ children }: { children: React.ReactNode }) {
  const [queryClient] = useState(() => new QueryClient({
    defaultOptions: {
      queries: {
        staleTime: 60 * 1000, // 1 minute
        refetchOnWindowFocus: false,
      }
    }
  }))
  
  return (
    <QueryClientProvider client={queryClient}>
      {children}
      <ReactQueryDevtools initialIsOpen={false} />
    </QueryClientProvider>
  )
}

// app/layout.tsx
import { Providers } from './providers'

export default function RootLayout({ children }: { children: React.ReactNode }) {
  return (
    <html>
      <body>
        <Providers>{children}</Providers>
      </body>
    </html>
  )
}
```

### ‚úÖ Zustand for Client State

**Use Zustand when you need:**
- Global UI state (theme, sidebar open/closed)
- Shared client-side state across components
- Simple, lightweight state management

**‚ùå AVOID Context + useReducer Boilerplate**
```typescript
// Too much boilerplate for simple state
const ThemeContext = createContext<ThemeContextType | undefined>(undefined)

function ThemeProvider({ children }: { children: React.ReactNode }) {
  const [theme, setTheme] = useState('light')
  return (
    <ThemeContext.Provider value={{ theme, setTheme }}>
      {children}
    </ThemeContext.Provider>
  )
}

function useTheme() {
  const context = useContext(ThemeContext)
  if (!context) throw new Error('useTheme must be used within ThemeProvider')
  return context
}
```

**‚úÖ USE Zustand**
```typescript
// lib/store.ts
import { create } from 'zustand'
import { persist } from 'zustand/middleware'

interface ThemeStore {
  theme: 'light' | 'dark'
  setTheme: (theme: 'light' | 'dark') => void
  toggleTheme: () => void
}

export const useTheme = create<ThemeStore>()(
  persist(
    (set) => ({
      theme: 'light',
      setTheme: (theme) => set({ theme }),
      toggleTheme: () => set((state) => ({ 
        theme: state.theme === 'light' ? 'dark' : 'light' 
      }))
    }),
    { name: 'theme-storage' }
  )
)

// In any component - no provider needed!
function ThemeToggle() {
  const { theme, toggleTheme } = useTheme()
  return <button onClick={toggleTheme}>{theme}</button>
}
```

**More Complex Zustand Example**
```typescript
// lib/store/cart.ts
import { create } from 'zustand'
import { devtools } from 'zustand/middleware'

interface CartItem {
  id: string
  name: string
  price: number
  quantity: number
}

interface CartStore {
  items: CartItem[]
  addItem: (item: Omit<CartItem, 'quantity'>) => void
  removeItem: (id: string) => void
  updateQuantity: (id: string, quantity: number) => void
  clearCart: () => void
  total: number
}

export const useCart = create<CartStore>()(
  devtools(
    (set, get) => ({
      items: [],
      
      addItem: (item) => set((state) => {
        const existing = state.items.find(i => i.id === item.id)
        if (existing) {
          return {
            items: state.items.map(i =>
              i.id === item.id ? { ...i, quantity: i.quantity + 1 } : i
            )
          }
        }
        return { items: [...state.items, { ...item, quantity: 1 }] }
      }),
      
      removeItem: (id) => set((state) => ({
        items: state.items.filter(i => i.id !== id)
      })),
      
      updateQuantity: (id, quantity) => set((state) => ({
        items: state.items.map(i =>
          i.id === id ? { ...i, quantity } : i
        )
      })),
      
      clearCart: () => set({ items: [] }),
      
      get total() {
        return get().items.reduce((sum, item) => sum + (item.price * item.quantity), 0)
      }
    })
  )
)
```

### üéØ State Management Decision Tree

```
Do you need to manage this state?
‚îÇ
‚îú‚îÄ Is it server data (from API/database)?
‚îÇ  ‚îú‚îÄ Is it in a Server Component? ‚Üí Use Server Components (fetch directly)
‚îÇ  ‚îî‚îÄ Is it in a Client Component? ‚Üí Use TanStack Query
‚îÇ
‚îú‚îÄ Is it URL state (filters, pagination)?
‚îÇ  ‚îî‚îÄ Use searchParams (Server) or useSearchParams (Client)
‚îÇ
‚îú‚îÄ Is it form state?
‚îÇ  ‚îú‚îÄ Simple form? ‚Üí Use Server Actions + useFormState
‚îÇ  ‚îî‚îÄ Complex form? ‚Üí Use react-hook-form
‚îÇ
‚îî‚îÄ Is it UI state (theme, modals, sidebar)?
   ‚îú‚îÄ Used in 1-2 components? ‚Üí Use useState + props
   ‚îú‚îÄ Used in 3-5 components? ‚Üí Lift state up or use Context
   ‚îî‚îÄ Used globally? ‚Üí Use Zustand
```

### ‚ùå Don't Use Redux in New Next.js Projects

**Why avoid Redux?**
- Server Components eliminate most need for global state
- Too much boilerplate for modern needs
- Better alternatives exist (Zustand, TanStack Query)

**When Redux is acceptable:**
- Migrating from existing large Redux codebase
- Team is deeply experienced with Redux
- Complex state machines that benefit from Redux DevTools time-travel

---

## ÔøΩüö® Common Anti-Patterns to Avoid

### ‚ùå Don't Fetch in Client Components
```typescript
// BAD
'use client'
function Users() {
  const [users, setUsers] = useState([])
  useEffect(() => {
    fetch('/api/users').then(r => r.json()).then(setUsers)
  }, [])
}

// GOOD - Server Component
async function Users() {
  const users = await db.users.findMany()
  return <UserList users={users} />
}
```

### ‚ùå Don't Use API Routes as a Proxy
```typescript
// BAD - Unnecessary API route
// app/api/users/route.ts
export async function GET() {
  const users = await db.users.findMany()
  return Response.json(users)
}

// GOOD - Direct database access in Server Component
async function Users() {
  const users = await db.users.findMany()
  return <UserList users={users} />
}
```

**Note:** API routes are for:
- Webhooks from external services
- Client-side fetch requests that can't be server components
- Authentication callbacks

### ‚ùå Don't Over-Use 'use client'
```typescript
// BAD - Entire page is client-side
'use client'
function Dashboard() {
  return (
    <div>
      <Header />
      <Stats />
      <Chart /> {/* Only this needs interactivity */}
    </div>
  )
}

// GOOD - Only interactive parts are client components
function Dashboard() { // Server Component
  return (
    <div>
      <Header />
      <Stats />
      <ChartClient /> {/* Only this is 'use client' */}
    </div>
  )
}
```

### ‚ùå Don't Ignore Loading States
```typescript
// BAD - No loading UI
async function Page() {
  const data = await fetchData() // User sees blank page while waiting
  return <div>{data}</div>
}

// GOOD - Proper loading UI
function Page() {
  return (
    <Suspense fallback={<Skeleton />}>
      <DataComponent />
    </Suspense>
  )
}

async function DataComponent() {
  const data = await fetchData()
  return <div>{data}</div>
}
```

### ‚ùå Don't Forget Error Boundaries
```typescript
// Add error.tsx for each route segment
// app/dashboard/error.tsx
'use client'

export default function Error({
  error,
  reset
}: {
  error: Error & { digest?: string }
  reset: () => void
}) {
  return (
    <div>
      <h2>Something went wrong!</h2>
      <button onClick={reset}>Try again</button>
    </div>
  )
}
```

---

## üìù Summary Checklist

### TypeScript & Code Quality
- [ ] Never use `any` - use proper types, `unknown`, or generics
- [ ] Avoid `useEffect` - use Server Components, Server Actions, or appropriate hooks

### Next.js Architecture
- [ ] Default to Server Components - only use 'use client' when necessary
- [ ] Fetch data in Server Components - avoid API routes as proxies
- [ ] Use Server Actions for mutations - embrace progressive enhancement
- [ ] Implement proper loading states with Suspense
- [ ] Add error boundaries with error.tsx
- [ ] Use `generateMetadata` for SEO
- [ ] Optimize data fetching patterns (parallel vs. sequential)

### HTTP & Data Fetching
- [ ] Prefer native `fetch` over Axios in Server Components
- [ ] Use TanStack Query for client-side data fetching (avoid `useEffect`)
- [ ] Configure axios instances properly if using it for legacy reasons

### State Management
- [ ] Use Server Components for server state when possible
- [ ] Use TanStack Query for client-side server state (API data)
- [ ] Use Zustand for global UI state (theme, modals, etc.)
- [ ] Avoid Redux in new projects - use modern alternatives
- [ ] Follow the state management decision tree

### Assets & Performance
- [ ] Always use `next/image` for images
- [ ] Optimize for Core Web Vitals

